# Documentation technique ‚Äì Backend OR D√©mat√©rialis√© ‚Üí Cr√©ation Contrat

### (Suite logique du document Frontend OR Physique ‚Üí Physique)

---

## Objectif

Mettre en place la logique **backend** permettant :

* de recevoir une demande d‚ÄôOrdre de R√©exp√©dition (OR) r√©alis√©e en ligne
* de valider les donn√©es m√©tier
* de persister une **Demande OR**
* de cr√©er automatiquement un **Contrat OR**
* d‚Äôexposer ce contrat dans l‚Äôinterface **back-office /contrat**

Cette documentation d√©crit la **conception**, le **workflow**, les **services**, les **mappings**, et les **choix techniques** r√©alis√©s.

---

## 1. Architecture backend ‚Äì Vue d‚Äôensemble

Le backend est d√©velopp√© en **Spring Boot / JHipster**, avec :

* Ressource REST : `OrDematResource`
* Services m√©tier :

  * `OrDematService`
  * `OrDematContratService`
* Mappers :

  * `DemandeOrMapper`
* Entit√©s :

  * `DemandeOr`
  * `Contrat`, `Titulaire`, `Adresse`
* Persistance JPA + JSONB

### Sch√©ma logique simplifi√©

```
POST /api/demat/or-physique
        ‚Üì
OrDematResource
        ‚Üì
OrDematService
        ‚Üì
DemandeOrMapper ‚Üí DemandeOr (JSONB + Instant)
        ‚Üì
DemandeOrService.save()
        ‚Üì
OrDematContratService
        ‚Üì
ContratService.saveContrat()
        ‚Üì
Contrat visible dans /contrat (back-office)
```

---

## 2. R√©ception de la demande ‚Äì OrDematRequestDTO

Le backend re√ßoit un **DTO issu du formulaire Angular**.

### Contenu principal :

* Dates : `dateDebut`, `dateFin` (format `yyyy-MM-dd`)
* Informations demandeur
* Ancienne et nouvelle adresse (JSON)

Ce DTO sert **exclusivement** √† la validation et √† la cr√©ation de la Demande OR.

---

## 3. Validation m√©tier ‚Äì OrDematService

La m√©thode centrale est :

```java
createDemandeOr(OrDematRequestDTO dto)
```

### R√®gles m√©tier appliqu√©es

‚úî dateDebut obligatoire
‚úî dateFin obligatoire
‚úî dateDebut ‚â• date du jour
‚úî dateFin > dateDebut
‚úî adresses obligatoires
‚úî ancienneAdresse ‚â† nouvelleAdresse

### Gestion des dates

Les dates re√ßues √©tant **sans heure**, elles sont converties ainsi :

```java
LocalDate ld = LocalDate.parse(dto.getDateDebut());
Instant instant = ld.atStartOfDay(ZoneId.systemDefault()).toInstant();
```

Cela √©vite les erreurs `Instant.parse()` et garantit une coh√©rence timezone.

---

## 4. Mapping vers DemandeOr ‚Äì DemandeOrMapper

Le mapper transforme :

* DTO ‚Üí Entity
* String ‚Üí Instant
* Donn√©es formulaire ‚Üí JSONB

### Conversion des dates

```java
public Instant toInstant(String date) {
    return LocalDate.parse(date)
        .atStartOfDay(ZoneId.systemDefault())
        .toInstant();
}
```

### Construction du champ `data` (JSONB)

```java
ObjectNode obj = objectMapper.createObjectNode();
obj.put("demandeurNom", dto.getDemandeurNom());
obj.set("ancienneAdresse", dto.getAncienneAdresse());
obj.set("nouvelleAdresse", dto.getNouvelleAdresse());
```

**Choix technique**
Le JSONB permet de conserver l‚Äôint√©gralit√© du formulaire sans multiplier les colonnes.

---

## 5. Entit√© DemandeOr

```java
@Entity
public class DemandeOr {

    private Instant dateDebut;
    private Instant dateFin;

    @Type(type = "jsonb")
    private JsonNode data;
}
```

- Une **Demande OR** repr√©sente une soumission en ligne
- Elle n‚Äôest **pas encore un contrat actif**

---

## 6. Cr√©ation automatique du Contrat OR

Apr√®s la sauvegarde de `DemandeOr`, le service appelle :

```java
orDematContratService.creerContratDepuisDemande(saved);
```

---

## 7. OrDematContratService ‚Äì C≈ìur de la fonctionnalit√©

Ce service :

* lit les donn√©es depuis `DemandeOr.data`
* cr√©e toutes les entit√©s n√©cessaires au Contrat OR

### √âtapes d√©taill√©es

1. Cr√©ation du `Contrat`
2. Initialisation du statut `DEMANDE_EN_LIGNE`
3. Cr√©ation du `Titulaire`
4. Mapping des 2 `Adresse`
5. Assemblage via `ContratCompletDTO`
6. Persistance avec `ContratService.saveContrat()`

---

## 8. Contraintes JPA importantes (retours d‚Äôexp√©rience)

### Champs obligatoires oubli√©s (Adresse)

Les entit√©s `Adresse` imposent :

```java
@NotNull Boolean isTitulaire;
@NotNull Boolean isAuthorize;
```

**Obligation** lors du mapping :

```java
adresse.setIsTitulaire(false);
adresse.setIsAuthorize(false);
```

Sans cela ‚Üí **RollbackException au commit**.

---

## 9. Statut du contrat OR

Le contrat est cr√©√© avec :

```java
contrat.setStatut(Statut.DEMANDE_EN_LIGNE);
```

üìò Ce statut permet :

* d‚Äôidentifier une demande issue du web
* de la distinguer des contrats cr√©√©s en agence
* de filtrer dans l‚Äôinterface `/contrat`

√Ä noter : `ContratService.saveContrat()` applique encore des r√®gles legacy
√† ajuster dans une √©volution ult√©rieure.

---


## 10. Probl√®mes rencontr√©s & solutions

### Parsing de date (`Instant.parse()`)

‚úî solution : `LocalDate ‚Üí Instant`

---

### ZonedDateTime.from(Instant)

‚úî solution :

```java
ZonedDateTime.ofInstant(instant, ZoneId.systemDefault());
```

---

### RollbackException JPA

‚úî cause : champs `@NotNull` non initialis√©s
‚úî correction : initialiser syst√©matiquement les bool√©ens

---
### √âcrasement du statut `DEMANDE_EN_LIGNE`

‚úî **Sympt√¥me**

- La demande OR cr√©√©e via le formulaire web :
  - cr√©e bien une ligne en base dans la table `contrat`
  - **mais le statut final est `CREE` au lieu de `DEMANDE_EN_LIGNE`**
- Les logs montraient pourtant :
  > "Contrat OR DEMANDE_EN_LIGNE cr√©√© avec succ√®s"

---

‚úî **Cause**

Le statut √©tait correctement positionn√© dans le service d√©mat√©rialis√© :

```java
contrat.setStatut(Statut.DEMANDE_EN_LIGNE);
````

Mais il √©tait **√©cras√© plus tard** dans le service m√©tier central :

```java
if (contrat.getId() == null) {
    addStatut(contrat);
}
```

Avec la m√©thode :

```java
private void addStatut(Contrat contrat) {
    contrat.setStatut(Statut.CREE);  // √©crase le statut existant
}
```

‚û°Ô∏è Cette logique historique supposait que **toute cr√©ation de contrat commen√ßait en `CREE`**, ce qui n‚Äôest plus valable pour le canal web.

---

‚úî **Solution**

Ne d√©finir le statut par d√©faut **que s‚Äôil n‚Äôest pas d√©j√† initialis√©** :

```java
private void addStatut(Contrat contrat) {
    if (contrat.getStatut() == null) {
        contrat.setStatut(Statut.CREE);
    }
    contrat.setImprEtiquette(false);
    contrat.setImprFicheRecap(false);
}
```

---

‚úî **R√©sultat**

* Cr√©ation bureau ‚Üí `CREE`
* Cr√©ation d√©mat√©rialis√©e ‚Üí `DEMANDE_EN_LIGNE`
* Aucun impact sur le workflow existant
* Le statut final en base est d√©sormais conforme √† la logique m√©tier

---
## Conclusion

Le backend OR d√©mat√©rialis√© :

* re√ßoit une demande en ligne
* valide les r√®gles m√©tier
* persiste une Demande OR
* cr√©e automatiquement un Contrat OR
* rend ce contrat visible et consultable en back-office

Cette impl√©mentation est **robuste**, **tra√ßable**, et **align√©e avec le workflow OR existant**.


